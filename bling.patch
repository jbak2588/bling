diff --git a/lib/features/local_news/screens/create_local_news_screen.dart b/lib/features/local_news/screens/create_local_news_screen.dart
index 6b65ea00115dde25aa3f75f0c3947f311bc1632d..fc7b92e0798e74c801bf4d2895f59f5f1e118f5d 100644
--- a/lib/features/local_news/screens/create_local_news_screen.dart
+++ b/lib/features/local_news/screens/create_local_news_screen.dart
@@ -57,57 +57,61 @@ class _CreateLocalNewsScreenState extends State<CreateLocalNewsScreen> {
     for (var image in _selectedImages) {
       final ref = FirebaseStorage.instance.ref(
           'post_images/${DateTime.now().millisecondsSinceEpoch}_${image.name}');
       final uploadTask = await ref.putFile(File(image.path));
       downloadUrls.add(await uploadTask.ref.getDownloadURL());
     }
     return downloadUrls;
   }
 
   Future<void> _submitPost() async {
     if (_contentController.text.trim().isEmpty) {
       ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('localNewsCreate.alerts.contentRequired'.tr())));
       return;
     }
     if (_selectedCategory == null) {
       ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('localNewsCreate.alerts.categoryRequired'.tr())));
       return;
     }
 
     setState(() => _isSubmitting = true);
 
     try {
       final user = FirebaseAuth.instance.currentUser;
-      if (user == null) throw Exception("로그인이 필요합니다.");
+      if (user == null) {
+        throw Exception('main.errors.loginRequired'.tr());
+      }
 
       final userDoc = await FirebaseFirestore.instance
           .collection('users')
           .doc(user.uid)
           .get();
-      if (!userDoc.exists) throw Exception("사용자 정보를 찾을 수 없습니다.");
+      if (!userDoc.exists) {
+        throw Exception('main.errors.userNotFound'.tr());
+      }
       final userModel = UserModel.fromFirestore(userDoc);
 
       final imageUrls = await _uploadImages();
       final tags = _tagsController.text
           .split(',')
           .map((tag) => tag.trim())
           .where((tag) => tag.isNotEmpty)
           .toList();
 
       final postData = {
         'userId': user.uid,
         'title': _titleController.text.trim(),
         'body': _contentController.text.trim(),
         'mediaUrl': imageUrls,
         'mediaType': imageUrls.isNotEmpty ? 'image' : null,
         'category': _selectedCategory!.categoryId,
         'tags': tags,
         'locationName': userModel.locationName,
         'locationParts': userModel.locationParts,
         'geoPoint': userModel.geoPoint,
         'createdAt': FieldValue.serverTimestamp(),
         'likesCount': 0,
         'commentsCount': 0,
         'viewsCount': 0,
         'thanksCount': 0,
diff --git a/lib/features/local_news/screens/edit_local_news_screen.dart b/lib/features/local_news/screens/edit_local_news_screen.dart
index ead36741df754c309be07157ea7444418a7454f3..cd93d08ce4da4c9feedea8839930c10b9d4c2739 100644
--- a/lib/features/local_news/screens/edit_local_news_screen.dart
+++ b/lib/features/local_news/screens/edit_local_news_screen.dart
@@ -110,87 +110,90 @@ class _EditLocalNewsScreenState extends State<EditLocalNewsScreen> {
     }
 
     setState(() => _isSubmitting = true);
 
     try {
       final newImageUrls = await _uploadImages();
       final finalImageUrls = [..._existingImageUrls, ...newImageUrls];
 
       final updatedData = {
         'title': _titleController.text.trim(),
         'body': _contentController.text.trim(),
         'mediaUrl': finalImageUrls,
         'mediaType': finalImageUrls.isNotEmpty ? 'image' : null,
         'category': _selectedCategory!.categoryId,
         'tags': _tags,
         'updatedAt': FieldValue.serverTimestamp(),
       };
 
       await FirebaseFirestore.instance
           .collection('posts')
           .doc(widget.post.id)
           .update(updatedData);
 
       if (!mounted) return;
       ScaffoldMessenger.of(context)
-          .showSnackBar(const SnackBar(content: Text('게시글이 수정되었습니다')));
+          .showSnackBar(
+              SnackBar(content: Text('localNewsEdit.alerts.success'.tr())));
       Navigator.of(context).pop(true);
     } catch (e) {
       if (mounted) {
         ScaffoldMessenger.of(context)
-            .showSnackBar(SnackBar(content: Text('수정 실패: $e')));
+            .showSnackBar(SnackBar(
+                content: Text('localNewsEdit.alerts.failure'
+                    .tr(namedArgs: {'error': e.toString()}))));
       }
     } finally {
       if (mounted) setState(() => _isSubmitting = false);
     }
   }
 
   // ✅ 커스텀 태그 위젯을 빌드하는 함수
   Widget _buildCustomChipsInput() {
     return Column(
       crossAxisAlignment: CrossAxisAlignment.start,
       children: [
         // 칩들을 보여주는 부분
         Wrap(
           spacing: 8.0,
           runSpacing: 4.0,
           children: _tags.map((tag) {
             return Chip(
               label: Text(tag),
               onDeleted: () {
                 setState(() {
                   _tags.remove(tag);
                 });
               },
             );
           }).toList(),
         ),
         // 새 태그를 입력하는 텍스트 필드
         TextField(
           controller: _tagInputController,
           decoration: InputDecoration(
-            labelText: '태그 입력 후 스페이스바 또는 완료',
+            labelText: 'localNewsEdit.form.tagInputLabel'.tr(),
             border: const OutlineInputBorder(),
           ),
           onChanged: (value) {
             // 스페이스바를 누르면 태그 추가
             if (value.endsWith(' ') && value.trim().isNotEmpty) {
               final newTag = value.trim();
               if (!_tags.contains(newTag)) {
                 setState(() {
                   _tags.add(newTag);
                 });
               }
               _tagInputController.clear();
             }
           },
           onSubmitted: (value) {
             // 키보드에서 완료(엔터)를 누르면 태그 추가
             final newTag = value.trim();
             if (newTag.isNotEmpty && !_tags.contains(newTag)) {
               setState(() {
                 _tags.add(newTag);
               });
             }
             _tagInputController.clear();
           },
         ),
@@ -207,60 +210,60 @@ class _EditLocalNewsScreenState extends State<EditLocalNewsScreen> {
         child: Column(
           crossAxisAlignment: CrossAxisAlignment.stretch,
           children: [
             DropdownButtonFormField<PostCategoryModel>(
               value: _selectedCategory,
               decoration: InputDecoration(
                   labelText: 'localNewsCreate.form.categoryLabel'.tr(),
                   border: const OutlineInputBorder()),
               items: AppCategories.postCategories.map((category) {
                 return DropdownMenuItem<PostCategoryModel>(
                   value: category,
                   child: Row(children: [
                     Text(category.emoji, style: const TextStyle(fontSize: 20)),
                     const SizedBox(width: 10),
                     Text(category.nameKey.tr()),
                   ]),
                 );
               }).toList(),
               onChanged: (value) {
                 if (value != null) setState(() => _selectedCategory = value);
               },
             ),
             const SizedBox(height: 16),
             TextField(
                 controller: _titleController,
-                decoration: const InputDecoration(
-                    labelText: '제목',
-                    border: OutlineInputBorder())),
+                decoration: InputDecoration(
+                    labelText: 'localNewsCreate.form.titleLabel'.tr(),
+                    border: const OutlineInputBorder())),
             const SizedBox(height: 16),
             TextField(
                 controller: _contentController,
                 maxLines: 8,
-                decoration: const InputDecoration(
-                    labelText: '내용',
-                    border: OutlineInputBorder())),
+                decoration: InputDecoration(
+                    labelText: 'localNewsCreate.form.contentLabel'.tr(),
+                    border: const OutlineInputBorder())),
             const SizedBox(height: 16),
             
             // ✅ 직접 만든 커스텀 태그 입력 위젯을 사용합니다.
             _buildCustomChipsInput(),
 
             const SizedBox(height: 16),
             _buildImagePicker(),
             const SizedBox(height: 24),
             ElevatedButton(
               style: ElevatedButton.styleFrom(
                   minimumSize: const Size(double.infinity, 50)),
               onPressed: _isSubmitting ? null : _updatePost,
               child: _isSubmitting
                   ? const CircularProgressIndicator(color: Colors.white)
                   : Text('localNewsEdit.buttons.submit'.tr()),
             ),
           ],
         ),
       ),
     );
   }
 
   Widget _buildImagePicker() {
     final existingImageCount = _existingImageUrls.length;
     final newImageCount = _newSelectedImages.length;
diff --git a/lib/features/local_news/screens/local_news_detail_screen.dart b/lib/features/local_news/screens/local_news_detail_screen.dart
index c144a23753637aafd24732a8c12a54332f53a4df..2e9d76f761b31772c7cb77fe24e889bdc3e213aa 100644
--- a/lib/features/local_news/screens/local_news_detail_screen.dart
+++ b/lib/features/local_news/screens/local_news_detail_screen.dart
@@ -80,51 +80,51 @@ class _LocalNewsDetailScreenState extends State<LocalNewsDetailScreen> {
     await _refreshPostData();
   }
 
   Future<void> _checkLiked() async {
     final user = FirebaseAuth.instance.currentUser;
     if (user == null) return;
     final doc = await FirebaseFirestore.instance
         .collection('users')
         .doc(user.uid)
         .get();
     if (mounted && doc.exists) {
       final userModel = UserModel.fromFirestore(doc);
       setState(() {
         _isLiked =
             userModel.bookmarkedPostIds?.contains(_currentPost.id) ?? false;
       });
     }
   }
 
   Future<void> _toggleLike() async {
     if (_likeLoading) return;
     setState(() => _likeLoading = true);
     final user = FirebaseAuth.instance.currentUser;
     if (user == null) {
       ScaffoldMessenger.of(context)
-          .showSnackBar(const SnackBar(content: Text('로그인이 필요합니다.')));
+          .showSnackBar(SnackBar(content: Text('main.errors.loginRequired'.tr())));
       setState(() => _likeLoading = false);
       return;
     }
     final postRef =
         FirebaseFirestore.instance.collection('posts').doc(_currentPost.id);
     final userRef =
         FirebaseFirestore.instance.collection('users').doc(user.uid);
     try {
       if (_isLiked) {
         await postRef.update({'likesCount': FieldValue.increment(-1)});
         await userRef.update({
           'bookmarkedPostIds': FieldValue.arrayRemove([_currentPost.id])
         });
         if (mounted) setState(() => _likesCount--);
       } else {
         await postRef.update({'likesCount': FieldValue.increment(1)});
         await userRef.update({
           'bookmarkedPostIds': FieldValue.arrayUnion([_currentPost.id])
         });
         if (mounted) setState(() => _likesCount++);
       }
       if (mounted) setState(() => _isLiked = !_isLiked);
     } finally {
       if (mounted) setState(() => _likeLoading = false);
     }
@@ -132,51 +132,51 @@ class _LocalNewsDetailScreenState extends State<LocalNewsDetailScreen> {
 
   Future<void> _increaseViewsCount() async {
     await FirebaseFirestore.instance
         .collection('posts')
         .doc(_currentPost.id)
         .update({'viewsCount': FieldValue.increment(1)});
   }
 
   void _handleReplyTap(String commentId) {
     setState(() {
       _activeReplyCommentId =
           (_activeReplyCommentId == commentId) ? null : commentId;
     });
   }
 
   Future<void> _toggleThanks() async {
     if (_isThanksProcessing) return;
     setState(() => _isThanksProcessing = true);
     final currentUserUid = FirebaseAuth.instance.currentUser?.uid;
     if (currentUserUid == null) {
       setState(() => _isThanksProcessing = false);
       return;
     }
     if (currentUserUid == _currentPost.userId) {
       ScaffoldMessenger.of(context).showSnackBar(
-          const SnackBar(content: Text('자신의 글에는 감사를 표시할 수 없습니다.')));
+          SnackBar(content: Text('localNewsDetail.alerts.cannotThankOwnPost'.tr())));
       setState(() => _isThanksProcessing = false);
       return;
     }
     final postRef =
         FirebaseFirestore.instance.collection('posts').doc(_currentPost.id);
     final authorRef =
         FirebaseFirestore.instance.collection('users').doc(_currentPost.userId);
     final thanksRef = postRef.collection('thanks').doc(currentUserUid);
 
     try {
       await FirebaseFirestore.instance.runTransaction((transaction) async {
         final thanksDoc = await transaction.get(thanksRef);
         if (thanksDoc.exists) {
           transaction
               .update(postRef, {'thanksCount': FieldValue.increment(-1)});
           transaction.update(
               authorRef, {'feedThanksReceived': FieldValue.increment(-1)});
           transaction.delete(thanksRef);
           if (mounted) setState(() => _thanksCount--);
         } else {
           transaction.update(postRef, {'thanksCount': FieldValue.increment(1)});
           transaction.update(
               authorRef, {'feedThanksReceived': FieldValue.increment(1)});
           transaction
               .set(thanksRef, {'thankedAt': FieldValue.serverTimestamp()});
diff --git a/lib/features/local_news/screens/local_news_screen.dart b/lib/features/local_news/screens/local_news_screen.dart
index 51c38577d75188992a1ac4870f3489090e34ce15..9366543f093b08f743c0d490646526ddfa674c2d 100644
--- a/lib/features/local_news/screens/local_news_screen.dart
+++ b/lib/features/local_news/screens/local_news_screen.dart
@@ -244,149 +244,149 @@ class _FeedMapView extends StatefulWidget {
   final UserModel? userModel;
   final Map<String, String?>? locationFilter;
   const _FeedMapView(
       {super.key, required this.category, this.userModel, this.locationFilter});
 
   @override
   State<_FeedMapView> createState() => _FeedMapViewState();
 }
 
 class _FeedMapViewState extends State<_FeedMapView> {
   final Completer<GoogleMapController> _controller = Completer();
 
   Future<CameraPosition> _getInitialCameraPosition() async {
     final snapshot = await _buildInitialCameraQuery().limit(1).get();
     LatLng target;
     if (snapshot.docs.isNotEmpty &&
         snapshot.docs.first.data()['geoPoint'] != null) {
       final geoPoint = snapshot.docs.first.data()['geoPoint'] as GeoPoint;
       target = LatLng(geoPoint.latitude, geoPoint.longitude);
     } else {
       target = LatLng(
         widget.userModel?.geoPoint?.latitude ?? -6.2088,
         widget.userModel?.geoPoint?.longitude ?? 106.8456,
       );
     }
-    debugPrint('[지도 디버그] 초기 카메라 위치 설정: $target');
+    debugPrint('[Map Debug] Initial camera position: $target');
     return CameraPosition(target: target, zoom: 14);
   }
 
   Query<Map<String, dynamic>> _buildInitialCameraQuery() {
     Query<Map<String, dynamic>> query =
         FirebaseFirestore.instance.collection('posts');
     final filter = widget.locationFilter;
 
     if (filter != null) {
       if (filter['kel'] != null) {
         query = query.where('locationParts.kel', isEqualTo: filter['kel']);
       } else if (filter['kec'] != null) {
         query = query.where('locationParts.kec', isEqualTo: filter['kec']);
       } else if (filter['kab'] != null) {
         query = query.where('locationParts.kab', isEqualTo: filter['kab']);
       } else if (filter['kota'] != null) {
         query = query.where('locationParts.kota', isEqualTo: filter['kota']);
       } else if (filter['prov'] != null) {
         query = query.where('locationParts.prov', isEqualTo: filter['prov']);
       }
     } else if (widget.userModel?.locationParts?['prov'] != null) {
       query = query.where('locationParts.prov',
           isEqualTo: widget.userModel!.locationParts!['prov']);
     }
 
     if (widget.category != 'all') {
       query = query.where('category', isEqualTo: widget.category);
     }
-    debugPrint('[지도 디버그] 카메라 위치 쿼리: ${query.parameters}');
+    debugPrint('[Map Debug] Camera position query: ${query.parameters}');
     return query.orderBy('createdAt', descending: true);
   }
 
   Query<Map<String, dynamic>> _buildAllMarkersQuery() {
     Query<Map<String, dynamic>> query =
         FirebaseFirestore.instance.collection('posts');
     
     if (widget.userModel?.locationParts?['prov'] != null) {
       query = query.where('locationParts.prov',
           isEqualTo: widget.userModel!.locationParts!['prov']);
     }
 
     if (widget.category != 'all') {
       query = query.where('category', isEqualTo: widget.category);
     }
-    debugPrint('[지도 디버그] 마커 생성 쿼리: ${query.parameters}');
+    debugPrint('[Map Debug] Marker creation query: ${query.parameters}');
     return query.orderBy('createdAt', descending: true);
   }
 
   Set<Marker> _createMarkers(
       List<QueryDocumentSnapshot<Map<String, dynamic>>> docs) {
-    debugPrint('[지도 디버그] 마커 생성을 위해 ${docs.length}개의 문서를 받았습니다.');
+    debugPrint('[Map Debug] Received ${docs.length} documents for markers.');
     final Set<Marker> markers = {};
     for (var doc in docs) {
       final post = PostModel.fromFirestore(doc);
       if (post.geoPoint != null) {
-        debugPrint('[지도 디버그] 핀 생성: ${post.id} at ${post.geoPoint!.latitude}, ${post.geoPoint!.longitude}');
+        debugPrint('[Map Debug] Created pin: ${post.id} at ${post.geoPoint!.latitude}, ${post.geoPoint!.longitude}');
         markers.add(Marker(
           markerId: MarkerId(post.id),
           position: LatLng(post.geoPoint!.latitude, post.geoPoint!.longitude),
           infoWindow: InfoWindow(
             title: post.title ?? post.body,
             snippet: post.locationName,
             onTap: () {
               Navigator.of(context).push(MaterialPageRoute(
                 builder: (_) => LocalNewsDetailScreen(post: post),
               ));
             },
           ),
         ));
       } else {
-        debugPrint('[지도 디버그] 핀 생성 실패 (geoPoint 없음): ${post.id}');
+        debugPrint('[Map Debug] Failed to create pin (no geoPoint): ${post.id}');
       }
     }
-    debugPrint('[지도 디버그] 총 ${markers.length}개의 마커를 생성했습니다.');
+    debugPrint('[Map Debug] Created total of ${markers.length} markers.');
     return markers;
   }
 
   @override
   Widget build(BuildContext context) {
     return FutureBuilder<CameraPosition>(
       future: _getInitialCameraPosition(),
       builder: (context, cameraSnapshot) {
         if (cameraSnapshot.connectionState == ConnectionState.waiting) {
           return const Center(child: CircularProgressIndicator());
         }
         if (!cameraSnapshot.hasData) {
           return GoogleMap(
               initialCameraPosition: const CameraPosition(
                   target: LatLng(-6.2088, 106.8456), zoom: 11));
         }
         return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
           stream: _buildAllMarkersQuery().snapshots(),
           builder: (context, postSnapshot) {
             if (postSnapshot.connectionState == ConnectionState.waiting) {
-              debugPrint('[지도 디버그] 게시물 데이터 로딩 중...');
+              debugPrint('[Map Debug] Loading post data...');
               return const Center(child: CircularProgressIndicator());
             }
              if (postSnapshot.hasError) {
-              debugPrint('[지도 디버그] 게시물 데이터 로딩 에러: ${postSnapshot.error}');
+              debugPrint('[Map Debug] Error loading post data: ${postSnapshot.error}');
               return Center(child: Text('Error: ${postSnapshot.error}'));
             }
             if (!postSnapshot.hasData) {
-              debugPrint('[지도 디버그] 게시물 데이터 없음.');
+              debugPrint('[Map Debug] No post data.');
               return Center(child: Text('No posts found.'));
             }
 
             final markers = _createMarkers(postSnapshot.data!.docs);
 
             return GoogleMap(
               initialCameraPosition: cameraSnapshot.data!,
               onMapCreated: (GoogleMapController controller) {
                 if (!_controller.isCompleted) {
                   _controller.complete(controller);
                 }
               },
               markers: markers,
             );
           },
         );
       },
     );
   }
 }
\ No newline at end of file
diff --git a/lib/features/local_news/screens/tag_search_result_screen.dart b/lib/features/local_news/screens/tag_search_result_screen.dart
index e22156813c69b974919832dd0f854e7e74aa01ec..4fbe65141d0ac5d692a4fdbf25cd2817490c321f 100644
--- a/lib/features/local_news/screens/tag_search_result_screen.dart
+++ b/lib/features/local_news/screens/tag_search_result_screen.dart
@@ -5,45 +5,53 @@ import 'package:cloud_firestore/cloud_firestore.dart';
 import 'package:flutter/material.dart';
 import 'package:easy_localization/easy_localization.dart';
 
 class TagSearchResultScreen extends StatelessWidget {
   final String tag;
   const TagSearchResultScreen({super.key, required this.tag});
 
   @override
   Widget build(BuildContext context) {
     return Scaffold(
       appBar: AppBar(
         title: Text('#$tag', style: const TextStyle(fontWeight: FontWeight.bold)),
       ),
       body: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
         // Firestore의 array-contains 쿼리를 사용하여 해당 태그를 포함하는 문서를 찾습니다.
         stream: FirebaseFirestore.instance
             .collection('posts')
             .where('tags', arrayContains: tag)
             .orderBy('createdAt', descending: true)
             .snapshots(),
         builder: (context, snapshot) {
           if (snapshot.connectionState == ConnectionState.waiting) {
             return const Center(child: CircularProgressIndicator());
           }
           if (snapshot.hasError) {
-            return Center(child: Text('검색 중 오류가 발생했습니다: ${snapshot.error}'));
+            return Center(
+              child: Text(
+                'localNewsTagSearch.errors.fetch'
+                    .tr(namedArgs: {'error': snapshot.error.toString()}),
+              ),
+            );
           }
           if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
-            return Center(child: Text('\'#$tag\' 태그가 포함된 게시물이 없습니다.'));
+            return Center(
+              child:
+                  Text('localNewsTagSearch.empty'.tr(namedArgs: {'tag': tag})),
+            );
           }
 
           final postDocs = snapshot.data!.docs;
           return ListView.builder(
             padding: const EdgeInsets.all(8.0),
             itemCount: postDocs.length,
             itemBuilder: (context, index) {
               final post = PostModel.fromFirestore(postDocs[index]);
               return PostCard(post: post);
             },
           );
         },
       ),
     );
   }
 }
diff --git a/lib/features/local_news/widgets/comment_input_field.dart b/lib/features/local_news/widgets/comment_input_field.dart
index b7f5b96be9307976eb266ae4f273cea40d644498..68f5010b95ae503426a656060d089254e5fd4b42 100644
--- a/lib/features/local_news/widgets/comment_input_field.dart
+++ b/lib/features/local_news/widgets/comment_input_field.dart
@@ -38,52 +38,55 @@ class _CommentInputFieldState extends State<CommentInputField> {
       'isSecret': _isSecret,
       'parentCommentId': null,
     };
 
     try {
       final postRef =
           FirebaseFirestore.instance.collection('posts').doc(widget.postId);
 
       // [수정] Firestore 트랜잭션 로직을 올바른 문법으로 수정합니다.
       await FirebaseFirestore.instance.runTransaction((transaction) async {
         // 1. 새로운 댓글이 추가될 DocumentReference를 먼저 생성합니다.
         final newCommentRef = postRef.collection('comments').doc();
 
         // 2. 게시물의 commentCount를 1 증가시킵니다.
         transaction.update(postRef, {'commentsCount': FieldValue.increment(1)});
 
         // 3. 생성된 참조에 댓글 데이터를 set 합니다.
         transaction.set(newCommentRef, commentData);
       });
 
       _controller.clear();
       setState(() => _isSecret = false);
       if (widget.onCommentAdded != null) widget.onCommentAdded!(commentData);
     } catch (e) {
       if (!mounted) return;
-      ScaffoldMessenger.of(context)
-          .showSnackBar(SnackBar(content: Text('댓글 등록 실패: $e')));
+      ScaffoldMessenger.of(context).showSnackBar(
+        SnackBar(
+            content: Text('commentInputField.alerts.failure'
+                .tr(namedArgs: {'error': e.toString()}))),
+      );
     } finally {
       if (mounted) setState(() => _isSending = false);
     }
   }
 
   // build 메소드는 기존과 동일하게 유지됩니다.
   @override
   Widget build(BuildContext context) {
     return Padding(
       padding: EdgeInsets.fromLTRB(
           8, 8, 8, MediaQuery.of(context).viewInsets.bottom + 8),
       child: Row(
         children: [
           // 비밀댓글 체크박스 (UI 예시)
           Checkbox(
             value: _isSecret,
             onChanged: (value) {
               setState(() {
                 _isSecret = value ?? false;
               });
             },
             visualDensity: VisualDensity.compact,
           ),
          Text('commentInputField.secretCommentLabel'.tr()),
           Expanded(
diff --git a/lib/features/local_news/widgets/post_card.dart b/lib/features/local_news/widgets/post_card.dart
index 308f5e752dd005489f9a128daec3f1d07ef35225..254b0ed9535763ab879584c4059c1928efc96d9e 100644
--- a/lib/features/local_news/widgets/post_card.dart
+++ b/lib/features/local_news/widgets/post_card.dart
@@ -123,51 +123,51 @@ class _PostCardState extends State<PostCard> {
               ),
               IconButton(onPressed: () {}, icon: const Icon(Icons.more_horiz_outlined)),
             ],
           ),
         );
       },
     );
   }
 
   // ✅ _buildLocationInfo 함수 추가
   Widget _buildLocationInfo(BuildContext context, String? locationName) {
     return Container(
       padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
       decoration: BoxDecoration(
         color: Colors.grey.shade100,
         borderRadius: BorderRadius.circular(8),
         border: Border.all(color: Colors.grey.shade200),
       ),
       child: Row(
         mainAxisSize: MainAxisSize.min,
         children: [
           Icon(Icons.location_on_outlined, color: Colors.grey.shade600, size: 16),
           const SizedBox(width: 8),
           Flexible(
             child: Text(
-              locationName ?? '위치 정보 있음',
+              locationName ?? 'localNews.locationAvailable'.tr(),
               style: TextStyle(color: Colors.grey.shade800, fontSize: 13),
               overflow: TextOverflow.ellipsis,
             ),
           ),
         ],
       ),
     );
   }
 
   Widget _buildTitleAndCategory(BuildContext context, PostModel post, PostCategoryModel category) {
     return Column(
       crossAxisAlignment: CrossAxisAlignment.start,
       children: [
         Row(
           children: [
             Text(category.emoji, style: const TextStyle(fontSize: 18)),
             const SizedBox(width: 8),
             Expanded(
               child: Text(
                 post.title ?? post.body,
                 style: GoogleFonts.inter(fontSize: 16, fontWeight: FontWeight.w600),
                 maxLines: 1,
                 overflow: TextOverflow.ellipsis,
               ),
             ),
